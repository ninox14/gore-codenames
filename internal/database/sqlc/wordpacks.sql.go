// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: wordpacks.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkWordpackExists = `-- name: CheckWordpackExists :one
SELECT EXISTS(SELECT 1 FROM wordpacks WHERE id = $1)
`

func (q *Queries) CheckWordpackExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkWordpackExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkWordpackNameExists = `-- name: CheckWordpackNameExists :one
SELECT EXISTS(SELECT 1 FROM wordpacks WHERE name = $1 AND id != $2)
`

type CheckWordpackNameExistsParams struct {
	Name string `db:"name" json:"name"`
	ID   int32  `db:"id" json:"id"`
}

func (q *Queries) CheckWordpackNameExists(ctx context.Context, arg CheckWordpackNameExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkWordpackNameExists, arg.Name, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countWordpacks = `-- name: CountWordpacks :one
SELECT COUNT(*) FROM wordpacks
`

func (q *Queries) CountWordpacks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countWordpacks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWordpacksByUser = `-- name: CountWordpacksByUser :one
SELECT COUNT(*) FROM wordpacks
WHERE created_by = $1
`

func (q *Queries) CountWordpacksByUser(ctx context.Context, createdBy *uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWordpacksByUser, createdBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWordpack = `-- name: CreateWordpack :one
INSERT INTO wordpacks (
    name, description, created_by, is_default, words
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, name, description, created_by, is_default, words
`

type CreateWordpackParams struct {
	Name        string      `db:"name" json:"name"`
	Description pgtype.Text `db:"description" json:"description"`
	CreatedBy   *uuid.UUID  `db:"created_by" json:"created_by"`
	IsDefault   pgtype.Bool `db:"is_default" json:"is_default"`
	Words       []string    `db:"words" json:"words"`
}

func (q *Queries) CreateWordpack(ctx context.Context, arg CreateWordpackParams) (Wordpack, error) {
	row := q.db.QueryRow(ctx, createWordpack,
		arg.Name,
		arg.Description,
		arg.CreatedBy,
		arg.IsDefault,
		arg.Words,
	)
	var i Wordpack
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsDefault,
		&i.Words,
	)
	return i, err
}

const deleteWordpack = `-- name: DeleteWordpack :exec
DELETE FROM wordpacks
WHERE id = $1
`

func (q *Queries) DeleteWordpack(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteWordpack, id)
	return err
}

const getWordpack = `-- name: GetWordpack :one
SELECT id, name, description, created_by, is_default, words FROM wordpacks
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetWordpack(ctx context.Context, id int32) (Wordpack, error) {
	row := q.db.QueryRow(ctx, getWordpack, id)
	var i Wordpack
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsDefault,
		&i.Words,
	)
	return i, err
}

const getWordpackByName = `-- name: GetWordpackByName :one
SELECT id, name, description, created_by, is_default, words FROM wordpacks
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetWordpackByName(ctx context.Context, name string) (Wordpack, error) {
	row := q.db.QueryRow(ctx, getWordpackByName, name)
	var i Wordpack
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsDefault,
		&i.Words,
	)
	return i, err
}

const getWordpacksByIDs = `-- name: GetWordpacksByIDs :many
SELECT id, name, description, created_by, is_default, words FROM wordpacks
WHERE id = ANY($1::int[])
`

func (q *Queries) GetWordpacksByIDs(ctx context.Context, dollar_1 []int32) ([]Wordpack, error) {
	rows, err := q.db.Query(ctx, getWordpacksByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wordpack
	for rows.Next() {
		var i Wordpack
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.IsDefault,
			&i.Words,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDefaultWordpacks = `-- name: ListDefaultWordpacks :many
SELECT id, name, description, created_by, is_default, words FROM wordpacks
WHERE is_default = true
ORDER BY name
`

func (q *Queries) ListDefaultWordpacks(ctx context.Context) ([]Wordpack, error) {
	rows, err := q.db.Query(ctx, listDefaultWordpacks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wordpack
	for rows.Next() {
		var i Wordpack
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.IsDefault,
			&i.Words,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWordpacks = `-- name: ListWordpacks :many
SELECT id, name, description, created_by, is_default, words FROM wordpacks
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListWordpacksParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListWordpacks(ctx context.Context, arg ListWordpacksParams) ([]Wordpack, error) {
	rows, err := q.db.Query(ctx, listWordpacks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wordpack
	for rows.Next() {
		var i Wordpack
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.IsDefault,
			&i.Words,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWordpacksByUser = `-- name: ListWordpacksByUser :many
SELECT id, name, description, created_by, is_default, words FROM wordpacks
WHERE created_by = $1
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListWordpacksByUserParams struct {
	CreatedBy *uuid.UUID `db:"created_by" json:"created_by"`
	Limit     int32      `db:"limit" json:"limit"`
	Offset    int32      `db:"offset" json:"offset"`
}

func (q *Queries) ListWordpacksByUser(ctx context.Context, arg ListWordpacksByUserParams) ([]Wordpack, error) {
	rows, err := q.db.Query(ctx, listWordpacksByUser, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wordpack
	for rows.Next() {
		var i Wordpack
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.IsDefault,
			&i.Words,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchWordpacks = `-- name: SearchWordpacks :many
SELECT id, name, description, created_by, is_default, words FROM wordpacks
WHERE name ILIKE $1 OR description ILIKE $1
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchWordpacksParams struct {
	Name   string `db:"name" json:"name"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) SearchWordpacks(ctx context.Context, arg SearchWordpacksParams) ([]Wordpack, error) {
	rows, err := q.db.Query(ctx, searchWordpacks, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wordpack
	for rows.Next() {
		var i Wordpack
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.IsDefault,
			&i.Words,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleWordpackDefault = `-- name: ToggleWordpackDefault :one
UPDATE wordpacks
SET is_default = $2
WHERE id = $1
RETURNING id, name, description, created_by, is_default, words
`

type ToggleWordpackDefaultParams struct {
	ID        int32       `db:"id" json:"id"`
	IsDefault pgtype.Bool `db:"is_default" json:"is_default"`
}

func (q *Queries) ToggleWordpackDefault(ctx context.Context, arg ToggleWordpackDefaultParams) (Wordpack, error) {
	row := q.db.QueryRow(ctx, toggleWordpackDefault, arg.ID, arg.IsDefault)
	var i Wordpack
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsDefault,
		&i.Words,
	)
	return i, err
}

const updateWordpack = `-- name: UpdateWordpack :one
UPDATE wordpacks
SET
    name = $2,
    description = $3,
    is_default = $4,
    words = $5
WHERE id = $1
RETURNING id, name, description, created_by, is_default, words
`

type UpdateWordpackParams struct {
	ID          int32       `db:"id" json:"id"`
	Name        string      `db:"name" json:"name"`
	Description pgtype.Text `db:"description" json:"description"`
	IsDefault   pgtype.Bool `db:"is_default" json:"is_default"`
	Words       []string    `db:"words" json:"words"`
}

func (q *Queries) UpdateWordpack(ctx context.Context, arg UpdateWordpackParams) (Wordpack, error) {
	row := q.db.QueryRow(ctx, updateWordpack,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.IsDefault,
		arg.Words,
	)
	var i Wordpack
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsDefault,
		&i.Words,
	)
	return i, err
}

const updateWordpackWords = `-- name: UpdateWordpackWords :one
UPDATE wordpacks
SET words = $2
WHERE id = $1
RETURNING id, name, description, created_by, is_default, words
`

type UpdateWordpackWordsParams struct {
	ID    int32    `db:"id" json:"id"`
	Words []string `db:"words" json:"words"`
}

func (q *Queries) UpdateWordpackWords(ctx context.Context, arg UpdateWordpackWordsParams) (Wordpack, error) {
	row := q.db.QueryRow(ctx, updateWordpackWords, arg.ID, arg.Words)
	var i Wordpack
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.IsDefault,
		&i.Words,
	)
	return i, err
}
