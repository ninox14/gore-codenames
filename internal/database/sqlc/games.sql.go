// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/ninox14/gore-codenames/internal/database/dto"
)

const countGamesByHost = `-- name: CountGamesByHost :one
SELECT COUNT(*) FROM games
WHERE host_id = $1
`

func (q *Queries) CountGamesByHost(ctx context.Context, hostID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countGamesByHost, hostID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGame = `-- name: CreateGame :one
INSERT INTO games (
    id,
    host_id,
    word_pack_id,
    game_state
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, host_id, created_at, started_at, status, word_pack_id, game_state
`

type CreateGameParams struct {
	ID         uuid.UUID      `db:"id" json:"id"`
	HostID     uuid.UUID      `db:"host_id" json:"host_id"`
	WordPackID int32          `db:"word_pack_id" json:"word_pack_id"`
	GameState  *dto.GameState `db:"game_state" json:"game_state"`
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, createGame,
		arg.ID,
		arg.HostID,
		arg.WordPackID,
		arg.GameState,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.Status,
		&i.WordPackID,
		&i.GameState,
	)
	return i, err
}

const deleteGame = `-- name: DeleteGame :exec
DELETE FROM games
WHERE id = $1
`

func (q *Queries) DeleteGame(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGame, id)
	return err
}

const getGameByID = `-- name: GetGameByID :one
SELECT id, host_id, created_at, started_at, status, word_pack_id, game_state FROM games
WHERE id = $1
`

func (q *Queries) GetGameByID(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, getGameByID, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.Status,
		&i.WordPackID,
		&i.GameState,
	)
	return i, err
}

const getGamesByHost = `-- name: GetGamesByHost :many
SELECT id, host_id, created_at, started_at, status, word_pack_id, game_state FROM games
WHERE host_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetGamesByHost(ctx context.Context, hostID uuid.UUID) ([]Game, error) {
	rows, err := q.db.Query(ctx, getGamesByHost, hostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HostID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.Status,
			&i.WordPackID,
			&i.GameState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesByHostAndStatus = `-- name: GetGamesByHostAndStatus :many
SELECT id, host_id, created_at, started_at, status, word_pack_id, game_state FROM games
WHERE host_id = $1
AND status = $2
ORDER BY created_at DESC
`

type GetGamesByHostAndStatusParams struct {
	HostID uuid.UUID  `db:"host_id" json:"host_id"`
	Status GameStatus `db:"status" json:"status"`
}

func (q *Queries) GetGamesByHostAndStatus(ctx context.Context, arg GetGamesByHostAndStatusParams) ([]Game, error) {
	rows, err := q.db.Query(ctx, getGamesByHostAndStatus, arg.HostID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HostID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.Status,
			&i.WordPackID,
			&i.GameState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesByStatus = `-- name: GetGamesByStatus :many
SELECT id, host_id, created_at, started_at, status, word_pack_id, game_state FROM games
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) GetGamesByStatus(ctx context.Context, status GameStatus) ([]Game, error) {
	rows, err := q.db.Query(ctx, getGamesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HostID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.Status,
			&i.WordPackID,
			&i.GameState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesByWordPack = `-- name: GetGamesByWordPack :many
SELECT id, host_id, created_at, started_at, status, word_pack_id, game_state FROM games
WHERE word_pack_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetGamesByWordPack(ctx context.Context, wordPackID int32) ([]Game, error) {
	rows, err := q.db.Query(ctx, getGamesByWordPack, wordPackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HostID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.Status,
			&i.WordPackID,
			&i.GameState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentGames = `-- name: GetRecentGames :many
SELECT id, host_id, created_at, started_at, status, word_pack_id, game_state FROM games
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetRecentGames(ctx context.Context, limit int32) ([]Game, error) {
	rows, err := q.db.Query(ctx, getRecentGames, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HostID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.Status,
			&i.WordPackID,
			&i.GameState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGameState = `-- name: UpdateGameState :one
UPDATE games
SET game_state = $2
WHERE id = $1
RETURNING id, host_id, created_at, started_at, status, word_pack_id, game_state
`

type UpdateGameStateParams struct {
	ID        uuid.UUID      `db:"id" json:"id"`
	GameState *dto.GameState `db:"game_state" json:"game_state"`
}

func (q *Queries) UpdateGameState(ctx context.Context, arg UpdateGameStateParams) (Game, error) {
	row := q.db.QueryRow(ctx, updateGameState, arg.ID, arg.GameState)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.Status,
		&i.WordPackID,
		&i.GameState,
	)
	return i, err
}

const updateGameStatus = `-- name: UpdateGameStatus :one
UPDATE games
SET status = $2,
    started_at = CASE
        WHEN $2 = 'Started' AND started_at IS NULL THEN CURRENT_TIMESTAMP
        ELSE started_at
    END
WHERE id = $1
RETURNING id, host_id, created_at, started_at, status, word_pack_id, game_state
`

type UpdateGameStatusParams struct {
	ID     uuid.UUID  `db:"id" json:"id"`
	Status GameStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateGameStatus(ctx context.Context, arg UpdateGameStatusParams) (Game, error) {
	row := q.db.QueryRow(ctx, updateGameStatus, arg.ID, arg.Status)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HostID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.Status,
		&i.WordPackID,
		&i.GameState,
	)
	return i, err
}
